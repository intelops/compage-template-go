package daos

import (
	"errors"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"{{.GitPlatformURL}}/{{.GitPlatformUserName}}/{{.GitRepositoryName}}/{{.NodeName}}/pkg/grpc/server/models"
	{{if .IsStringID}}
        "github.com/google/uuid"
    {{end}}
)

{{if .IsStringID}}
var {{.SmallResourceNamePlural}} = make(map[string]*models.{{.CapsResourceNameSingular}})
{{end}}
{{if .IsIntID}}
var {{.SmallResourceNamePlural}} = make(map[int64]*models.{{.CapsResourceNameSingular}})
{{end}}

type {{.CapsResourceNameSingular}}Dao struct {
}

func New{{.CapsResourceNameSingular}}Dao() (*{{.CapsResourceNameSingular}}Dao, error) {
	return &{{.CapsResourceNameSingular}}Dao{
	}, nil
}

{{ if .IsGRPCCreateAllowed }}
func ({{.SmallResourceNameSingular}}Dao *{{.CapsResourceNameSingular}}Dao) Create{{.CapsResourceNameSingular}}({{.SmallResourceNameSingular}} *models.{{.CapsResourceNameSingular}})  (*models.{{.CapsResourceNameSingular}}, error) {
{{if .IsStringID}}
    {{.SmallResourceNameSingular}}.ID = uuid.New().String()
{{end}}
{{if .IsIntID}}
    {{.SmallResourceNameSingular}}.ID = int64(len({{.SmallResourceNamePlural}}) + 1)
{{end}}
	{{.SmallResourceNamePlural}}[{{.SmallResourceNameSingular}}.ID] = {{.SmallResourceNameSingular}}

	return {{.SmallResourceNameSingular}}, nil
}
{{ end }}

{{ if .IsGRPCListAllowed }}
func ({{.SmallResourceNameSingular}}Dao *{{.CapsResourceNameSingular}}Dao) List{{.CapsResourceNamePlural}}() ([]*models.{{.CapsResourceNameSingular}}, error) {
	v := make([]*models.{{.CapsResourceNameSingular}}, len({{.SmallResourceNamePlural}}))
	for _, value := range {{.SmallResourceNamePlural}} {
		v = append(v, value)
	}

	return v, nil
}
{{ end }}

{{ if .IsGRPCGetAllowed }}
func ({{.SmallResourceNameSingular}}Dao *{{.CapsResourceNameSingular}}Dao) Get{{.CapsResourceNameSingular}}(id {{GetPrimaryKeyType}}) (*models.{{.CapsResourceNameSingular}}, error) {
	if id == 0 {
		return nil, status.Error(codes.InvalidArgument, "id can't be empty")
	}

	if {{.SmallResourceNameSingular}}, ok := {{.SmallResourceNamePlural}}[id]; ok {
		return {{.SmallResourceNameSingular}}, nil
	}

	return &models.{{.CapsResourceNameSingular}}{}, errors.New("{{.SmallResourceNameSingular}} not found")
}
{{ end }}

{{ if .IsGRPCPutAllowed }}
func ({{.SmallResourceNameSingular}}Dao *{{.CapsResourceNameSingular}}Dao) Update{{.CapsResourceNameSingular}}(id {{GetPrimaryKeyType}}, {{.SmallResourceNameSingular}} *models.{{.CapsResourceNameSingular}}) (*models.{{.CapsResourceNameSingular}}, error) {
{{if .IsIntID}}
    if id == 0 {
        return nil, errors.New("invalid {{.SmallResourceNameSingular}} ID")
    }
    if id != m.ID {
        return nil, errors.New("id and payload don't match")
    }
{{end}}
{{if .IsStringID}}
    if len(id) < 1 {
        return nil, errors.New("invalid {{.SmallResourceNameSingular}} ID")
    }
    if strings.EqualFold(id, m.ID.String()) {
        return nil, errors.New("id and payload don't match")
    }
{{end}}
	{{.SmallResourceNamePlural}}[{{.SmallResourceNameSingular}}.ID] = {{.SmallResourceNameSingular}}

	return {{.SmallResourceNameSingular}}, nil
}
{{ end }}

{{ if .IsGRPCDeleteAllowed }}
func ({{.SmallResourceNameSingular}}Dao *{{.CapsResourceNameSingular}}Dao) Delete{{.CapsResourceNameSingular}}(id {{GetPrimaryKeyType}}) error {
	if _, ok := {{.SmallResourceNamePlural}}[id]; ok {
		delete({{.SmallResourceNamePlural}}, id)
		return nil
	}

	return errors.New("{{.SmallResourceNameSingular}} not found")
}
{{ end }}