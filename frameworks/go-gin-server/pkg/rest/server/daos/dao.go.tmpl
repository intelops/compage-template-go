package daos

import (
	"errors"
	"{{.GitPlatformURL}}/{{.GitPlatformUserName}}/{{.GitRepositoryName}}/{{.NodeName}}/pkg/rest/server/models"
{{if .IsStringID}}
    "github.com/google/uuid"
{{end}}
)

{{if .IsStringID}}
var {{.SmallResourceNamePlural}} = make(map[string]*models.{{.CapsResourceNameSingular}})
{{end}}
{{if .IsIntID}}
var {{.SmallResourceNamePlural}} = make(map[int64]*models.{{.CapsResourceNameSingular}})
{{end}}

type {{.CapsResourceNameSingular}}Dao struct {
}

func New{{.CapsResourceNameSingular}}Dao() (*{{.CapsResourceNameSingular}}Dao, error) {
	return &{{.CapsResourceNameSingular}}Dao{
	}, nil
}

{{ if .IsRESTCreateAllowed }}
func ({{.SmallResourceNameSingular}}Dao *{{.CapsResourceNameSingular}}Dao) Create{{.CapsResourceNameSingular}}({{.SmallResourceNameSingular}} *models.{{.CapsResourceNameSingular}})  (*models.{{.CapsResourceNameSingular}}, error) {
	{{.SmallResourceNamePlural}}[{{.SmallResourceNameSingular}}.ID] = {{.SmallResourceNameSingular}}

	return {{.SmallResourceNameSingular}}, nil
}
{{ end }}

{{ if .IsRESTListAllowed }}
func ({{.SmallResourceNameSingular}}Dao *{{.CapsResourceNameSingular}}Dao) List{{.CapsResourceNamePlural}}() ([]*models.{{.CapsResourceNameSingular}}, error) {
	v := make([]*models.{{.CapsResourceNameSingular}}, len({{.SmallResourceNamePlural}}))
	for _, value := range {{.SmallResourceNamePlural}} {
		v = append(v, value)
	}

	return v, nil
}
{{ end }}

{{ if .IsRESTGetAllowed }}
func ({{.SmallResourceNameSingular}}Dao *{{.CapsResourceNameSingular}}Dao) Get{{.CapsResourceNameSingular}}(id {{GetPrimaryKeyType}}) (*models.{{.CapsResourceNameSingular}}, error) {
	if {{.SmallResourceNameSingular}}, ok := {{.SmallResourceNamePlural}}[id]; ok {
		return {{.SmallResourceNameSingular}}, nil
	}

	return &models.{{.CapsResourceNameSingular}}{}, errors.New("{{.SmallResourceNameSingular}} not found")
}
{{ end }}

{{ if .IsRESTPutAllowed }}
func ({{.SmallResourceNameSingular}}Dao *{{.CapsResourceNameSingular}}Dao) Update{{.CapsResourceNameSingular}}(id {{GetPrimaryKeyType}}, {{.SmallResourceNameSingular}} *models.{{.CapsResourceNameSingular}}) (*models.{{.CapsResourceNameSingular}}, error) {
{{if .IsIntID}}
    if id == 0 {
        return nil, errors.New("invalid {{.SmallResourceNameSingular}} ID")
    }
    if id != m.ID {
        return nil, errors.New("id and payload don't match")
    }
{{end}}
{{if .IsStringID}}
    if len(id) < 1 {
        return nil, errors.New("invalid {{.SmallResourceNameSingular}} ID")
    }
    if strings.EqualFold(id, m.ID.String()) {
        return nil, errors.New("id and payload don't match")
    }
{{end}}
	{{.SmallResourceNamePlural}}[{{.SmallResourceNameSingular}}.ID] = {{.SmallResourceNameSingular}}

	return {{.SmallResourceNameSingular}}, nil
}
{{ end }}

{{ if .IsRESTDeleteAllowed }}
func ({{.SmallResourceNameSingular}}Dao *{{.CapsResourceNameSingular}}Dao) Delete{{.CapsResourceNameSingular}}(id {{GetPrimaryKeyType}}) error {
	if _, ok := {{.SmallResourceNamePlural}}[id]; ok {
		delete({{.SmallResourceNamePlural}}, id)
		return nil
	}

	return errors.New("{{.SmallResourceNameSingular}} not found")
}
{{ end }}